import os
import re
import json
import shutil
from multiprocessing import Pool, Manager, cpu_count
from docx import Document
from docx.shared import RGBColor
import xlsxwriter
from tqdm import tqdm

# === CONFIG ===
INPUT_FILE   = "input.txt"                # your Aerospike log file
CHUNK_SIZE   = 2000                       # how many records per worker
OUTPUT_DOCX  = "aerospike_mobiles.docx"
OUTPUT_XLSX  = "aerospike_mobiles.xlsx"
TEMP_DIR     = "temp_aero_parts"

MOBILE_REGEX = r'(?<!\d)((?:\+91[\-\s]?|91[\-\s]?|0)?[6-9]\d{9})(?!\d)'

# === FLATTEN JSON ===
def flatten_json(obj, prefix=""):
    flat = {}
    if isinstance(obj, dict):
        for k, v in obj.items():
            path = f"{prefix}{k}"
            if isinstance(v, (dict, list)):
                flat.update(flatten_json(v, path + "."))
            elif isinstance(v, str) and v.strip().startswith(("{", "[")):
                try:
                    inner = json.loads(v)
                except:
                    flat[path] = v
                else:
                    flat.update(flatten_json(inner, path + "."))
            else:
                flat[path] = v
    elif isinstance(obj, list):
        for i, item in enumerate(obj):
            flat.update(flatatten_json(item, f"{prefix}[{i}]."))
    return flat


# === LOAD & GROUP RECORDS ===
def load_records():
    """
    Simplified loader: 
    - Skip blank and lone-brace lines
    - On any line containing 'Set Name:' extract set_name & key
    - After 'JSON Data:' start buffering JSON (first '{' through matching '}')
    - Return records plus warnings & skipped lines
    """
    header_re = re.compile(
        r"Set\s+Name\s*:\s*([^,]+)"             # group1 = set_name
        r"(?:\s*,\s*Key\s*:\s*([^,]+))?"        # opt group2 = key
        r".*JSON\s*Data\s*:\s*(\{?)",           # group3 = leading '{' if present
        flags=re.IGNORECASE
    )

    records = []
    skipped = []
    warnings = 0

    current = None  # (set_name, key, brace_count, buffer_json)

    with open(INPUT_FILE, "r", encoding="utf-8", errors="ignore") as f:
        for lineno, raw in enumerate(f,1):
            line = raw.rstrip("\r\n")

            # skip blank or lone braces
            if not line.strip() or line.strip() in ("{", "}"):
                continue

            if "set name:" in line.lower():
                # if previous still open, warn + skip it
                if current and current[2] > 0:
                    warnings += 1
                    skipped.append((lineno, f"unclosed {current[0]}"))
                m = header_re.search(line)
                if not m:
                    warnings += 1
                    skipped.append((lineno, line))
                    current = None
                    continue

                set_name = m.group(1).strip()
                key      = (m.group(2) or "").strip()
                leading  = m.group(3) or ""
                brace_count = leading.count("{") - leading.count("}")
                buffer_json = []
                # if we saw a '{' on header, include it
                if leading == "{":
                    buffer_json.append("{")
                current = [set_name, key, brace_count, buffer_json]
                continue

            if current:
                current[3].append(line)
                # count braces
                current[2] += line.count("{") - line.count("}")
                # closed?
                if current[2] == 0:
                    # finalize
                    recs_name, recs_key, _, buf = current
                    raw_json = "\n".join(buf)
                    records.append((recs_name, recs_key, raw_json))
                    current = None
                continue

            # else outside record
            warnings += 1
            skipped.append((lineno, line))

        # if still open at EOF
        if current and current[2] != 0:
            warnings += 1
            skipped.append(("EOF", f"unclosed {current[0]}"))

    return records, warnings, skipped


# === (rest of your script unchanged) ===
# chunk_records, process_chunk, merge_word, write_excel, __main__...
