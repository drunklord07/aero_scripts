#!/usr/bin/env python3
import os
import glob
import re
import subprocess
import argparse
import shutil
import sys
from concurrent.futures import ThreadPoolExecutor, as_completed
from tqdm import tqdm
import pandas as pd

def find_scripts():
    """Recursively find all .py files except this driver."""
    me = os.path.abspath(__file__)
    scripts = [
        fn for fn in glob.glob("**/*.py", recursive=True)
        if os.path.abspath(fn) != me
    ]
    return sorted(scripts)

def parse_expected_outputs(script_path):
    """
    Peek at the script source to find OUTPUT_XLSX and OUTPUT_DOCX.
    Falls back to <basename>.xlsx/.docx.
    """
    base = os.path.splitext(os.path.basename(script_path))[0]
    text = open(script_path, encoding="utf-8", errors="ignore").read()
    m_x = re.search(r'OUTPUT_XLSX\s*=\s*["\'](.+?\.xlsx)["\']', text)
    m_d = re.search(r'OUTPUT_DOCX\s*=\s*["\'](.+?\.docx)["\']', text)
    xlsx = m_x.group(1) if m_x else f"{base}.xlsx"
    docx = m_d.group(1) if m_d else f"{base}.docx"
    return xlsx, docx

def run_script(path):
    """
    Run `python path` from cwd. Capture output, return dictionary with:
      - path, basename, returncode, log
      - expected_xlsx/docx
      - missing outputs
    """
    base = os.path.splitext(os.path.basename(path))[0]
    exp_xlsx, exp_docx = parse_expected_outputs(path)

    proc = subprocess.run(
        [sys.executable, path],
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
        encoding='utf-8',
        errors='replace'
    )

    missing = []
    for fn in (exp_xlsx, exp_docx):
        if not os.path.isfile(fn):
            missing.append(fn)

    return {
        "path": path,
        "basename": base,
        "returncode": proc.returncode,
        "expected_xlsx": exp_xlsx,
        "expected_docx": exp_docx,
        "missing": missing,
        "log": proc.stdout,
    }

def main():
    p = argparse.ArgumentParser(description="Master runner for Aerospike extractors")
    p.add_argument("-c", "--combined", default="combined_output.xlsx",
                   help="Master Excel filename")
    p.add_argument("-j", "--max-parallel", type=int, default=3,
                   help="Max concurrent scripts")
    args = p.parse_args()

    scripts = find_scripts()
    print(f"Found {len(scripts)} scripts to run.\n")

    # Ensure outputs directory exists
    out_dir = "outputs"
    if os.path.isdir(out_dir):
        shutil.rmtree(out_dir)
    os.makedirs(out_dir)

    results = []
    with ThreadPoolExecutor(max_workers=args.max_parallel) as exe:
        futures = {exe.submit(run_script, s): s for s in scripts}
        for fut in tqdm(as_completed(futures),
                        total=len(futures),
                        desc="Running scripts",
                        ascii=True):
            res = fut.result()
            results.append(res)
            name = res["basename"]
            if res["returncode"] != 0:
                print(f"[ERROR] {name} exited {res['returncode']}")
                print(res["log"])
            elif res["missing"]:
                print(f"[WARN] {name} missing: {res['missing']}")
            else:
                # copy outputs
                for fn in (res["expected_docx"], res["expected_xlsx"]):
                    if os.path.exists(fn):
                        shutil.copy(fn, os.path.join(out_dir, fn))

    total = len(results)
    ok = sum(1 for r in results if r["returncode"] == 0 and not r["missing"])
    print(f"\nScripts run: {total}, succeeded: {ok}, failed/skipped: {total-ok}\n")

    # Merge Excel
    excels = [
        os.path.join(out_dir, r["expected_xlsx"])
        for r in results
        if r["returncode"] == 0 and not r["missing"]
        and os.path.isfile(os.path.join(out_dir, r["expected_xlsx"]))
    ]
    if not excels:
        print("No Excel files to merge.")
        sys.exit(1)

    print(f"Merging {len(excels)} Excel files into '{args.combined}'")
    with pd.ExcelWriter(args.combined, engine="xlsxwriter") as writer:
        for f in tqdm(excels, desc="Merging sheets", ascii=True):
            df = pd.read_excel(f)
            sheet = os.path.splitext(os.path.basename(f))[0][:31]
            df.to_excel(writer, sheet_name=sheet, index=False)

    print(f"\nMaster workbook created: {args.combined}")
    print(f"Outputs directory: {out_dir}")
    sys.exit(0 if ok == total else 1)

if __name__ == "__main__":
    main()
