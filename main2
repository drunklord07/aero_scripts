#!/usr/bin/env python3
import os
import glob
import re
import subprocess
import argparse
import shutil
import sys
from concurrent.futures import ThreadPoolExecutor, as_completed
from tqdm import tqdm
import pandas as pd

# --- force ASCII-only printing to avoid charmap errors ---
def safe_print(*args, **kwargs):
    msg = " ".join(str(a) for a in args)
    msg = msg.encode("ascii", "ignore").decode("ascii")
    print(msg, **kwargs)

def find_scripts():
    me = os.path.abspath(__file__)
    return sorted(
        fn for fn in glob.glob("**/*.py", recursive=True)
        if os.path.abspath(fn) != me
    )

def parse_expected_outputs(path):
    base = os.path.splitext(os.path.basename(path))[0]
    text = open(path, encoding="utf-8", errors="ignore").read()
    m_x = re.search(r'OUTPUT_XLSX\s*=\s*["\'](.+?\.xlsx)["\']', text)
    # We ignore OUTPUT_DOCX here
    xlsx = m_x.group(1) if m_x else f"{base}.xlsx"
    return xlsx

def run_script(path):
    exp_xlsx = parse_expected_outputs(path)
    env = os.environ.copy()
    env["PYTHONIOENCODING"] = "utf-8"
    proc = subprocess.run(
        [sys.executable, path],
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
        env=env,
        errors="replace"
    )
    # Only consider .xlsx for success
    missing_xlsx = not os.path.isfile(exp_xlsx)
    return {
        "basename": os.path.splitext(os.path.basename(path))[0],
        "path": path,
        "returncode": proc.returncode,
        "expected_xlsx": exp_xlsx,
        "missing_xlsx": missing_xlsx,
        "log": proc.stdout,
    }

def main():
    p = argparse.ArgumentParser(description="Run extractors & merge XLSX")
    p.add_argument("-c", "--combined", default="combined_output.xlsx",
                   help="Master Excel filename")
    p.add_argument("-j", "--max-parallel", type=int, default=3,
                   help="Max concurrent scripts")
    args = p.parse_args()

    scripts = find_scripts()
    safe_print(f"Found {len(scripts)} scripts to run.\n")

    out_dir = "outputs"
    if os.path.isdir(out_dir):
        shutil.rmtree(out_dir)
    os.makedirs(out_dir)

    results = []
    with ThreadPoolExecutor(max_workers=args.max_parallel) as exe:
        futures = {exe.submit(run_script, s): s for s in scripts}
        for fut in tqdm(as_completed(futures),
                        total=len(futures),
                        desc="Running scripts",
                        ascii=True):
            res = fut.result()
            results.append(res)
            name = res["basename"]
            if res["returncode"] != 0:
                safe_print(f"[ERROR] {name} exited {res['returncode']}")
                safe_print(res["log"])
            if res["missing_xlsx"]:
                safe_print(f"[WARN] {name} missing XLSX: {res['expected_xlsx']}")
            else:
                # copy XLSX
                src = res["expected_xlsx"]
                dst = os.path.join(out_dir, os.path.basename(src))
                shutil.copy(src, dst)
                # also copy DOCX if exists
                docx = os.path.splitext(src)[0] + ".docx"
                if os.path.isfile(docx):
                    shutil.copy(docx, os.path.join(out_dir, os.path.basename(docx)))

    total = len(results)
    succeeded = sum(not r["missing_xlsx"] for r in results)
    safe_print(f"\nScripts run: {total}, succeeded: {succeeded}, failed: {total - succeeded}\n")

    excels = sorted(f for f in os.listdir(out_dir) if f.endswith(".xlsx"))
    if not excels:
        safe_print("No Excel files to merge. Exiting.")
        sys.exit(1)

    safe_print(f"Merging {len(excels)} Excel files into '{args.combined}' â€¦")
    total_rows = 0
    with pd.ExcelWriter(args.combined, engine="xlsxwriter") as writer:
        for fname in tqdm(excels, desc="Merging sheets", ascii=True):
            path = os.path.join(out_dir, fname)
            try:
                df = pd.read_excel(path)
            except Exception as e:
                safe_print(f"[WARN] could not read {fname}: {e}")
                continue
            sheet = os.path.splitext(fname)[0][:31]
            df.to_excel(writer, sheet_name=sheet, index=False)
            total_rows += len(df)

    safe_print(f"\nMaster workbook created: {args.combined}")
    safe_print(f"Total rows across all sheets: {total_rows}")
    safe_print(f"Outputs collected in: ./{out_dir}")
    sys.exit(0 if succeeded == total else 1)

if __name__ == "__main__":
    main()
